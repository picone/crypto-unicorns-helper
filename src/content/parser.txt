import { TCompactProtocol, TFramedTransport } from 'thrift'
import { RspGroupListenerRegister, MsgGroupUpdate } from '../gen-nodejs/cu_types'
const Buffer = require('buffer/').Buffer
import { decode as DecodeMsgPack } from '@msgpack/msgpack'
import { Building, BuildingEvent, BuildingSlot, DataStore, Land } from '../models/game'

export class CUParser {
    data: DataStore = new DataStore()
    private ws: WebSocket
    constructor(ws: WebSocket) {
        this.ws = ws
    }

    parse(data: object): void {
        if (!data || !(data instanceof ArrayBuffer) || data.byteLength < 7) {
            return
        }
        const dv = new DataView(data)
        if (dv.getUint8(0) != 4) {
            return
        }
        const command = dv.getUint16(1)
        let dataOffset = 4
        if (dv.getUint8(3) == 0x80) {
            dataOffset = 6
        }
        const buf = data.slice(dataOffset, data.byteLength)
        const protocol = new TCompactProtocol(new TFramedTransport(new Buffer(buf)))
        switch (command) {
            case 314:
                ((protocol: TCompactProtocol) => {
                    const msg: any = new RspGroupListenerRegister()
                    msg.read(protocol)
                    if (!msg?.group?.props) {
                        return
                    }
                    if (msg.group?.base?.type != 'lod1') {
                        return
                    }
                    const landId = parseInt(msg.group?.base?.id?.substr(5), 10)
                    this.updateLand(landId, DecodeMsgPack(msg?.group?.props))
                })(protocol)
                break
            case 350:
                ((protocol: TCompactProtocol) => {
                    const msg: any = new MsgGroupUpdate()
                    msg.read(protocol)
                    if (!msg?.group?.props) {
                        return
                    }
                    if (!msg?.name?.startsWith('lod1/')) {
                        return
                    }
                    const landId = parseInt(msg.name.substr(5), 10)
                    this.updateLand(landId, DecodeMsgPack(msg?.group?.props))
                })(protocol)
                break
            default:
                return
        }
    }

    updateLand(landId: number, msg: any): void {
        let land: Land
        if (this.data.lands.has(landId)) {
            land = this.data.lands.get(landId)!
        } else {
            land = new Land()
            this.data.lands.set(landId, land)
        }
        land.id = landId
        land.name = msg.land?.name || land.name
        land.class = msg?.land?.type || msg?.land?.class || land.class
        land.level = msg?.land?.level || land.level
        land.xp = msg?.land?.xp || msg?.state?.xp || land.xp
        if (msg?.buildings) {
            for (const buildingId in msg?.buildings) {
                const item = msg?.buildings[buildingId]
                const building = new Building()
                building.id = buildingId
                building.type = item?.type
                building.level = item?.level
                building.state = item?.state
                building.events = item?.events?.map((evt: any) => {
                    return new BuildingEvent(evt.timestamp)
                })
                if (item?.type === 'nursery' && (item?.state === 'breeding_in_progress'
                    || item?.state === 'breeding_finished')) {
                    const breeding = item?.data?.breeding
                    const slot = new BuildingSlot()
                    slot.completedAt = breeding?.end_time
                    slot.startAt = breeding?.start_time
                    slot.state = item.state === 'breeding_in_progress' ? 'in_progress' : 'collectable'
                    building.slots.set(0, slot)
                } else if (item?.type === 'nursery' && (item?.state === 'evolution_in_progress'
                || item?.state === 'evolution_finished')) {
                    const evolution = item?.data?.evolution
                    const slot = new BuildingSlot()
                    slot.completedAt = evolution?.end_time
                    slot.startAt = evolution?.start_time
                    slot.state = item.state === 'evolution_in_progress' ? 'in_progress' : 'collectable'
                    building.slots.set(0, slot)
                } else {
                    for (const slotId in item?.data?.slots) {
                        const slotItem = item?.data?.slots[slotId]
                        if (slotItem?.is_lock) {
                            continue
                        }
                        const slot = new BuildingSlot()
                        slot.completedAt = slotItem?.data?.complete_at
                        slot.startAt = slotItem?.data?.start_at
                        slot.state = slotItem?.data?.state
                        building.slots.set(parseInt(slotId), slot)
                    }
                }
                land.buildings.set(buildingId, building)
            }
        }
    }

    collectAll(): void {
        console.log(this.ws)
    }
}
